package mechanism.sensor;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.HashMap;

import edu.wpi.first.wpilibj.vision.VisionPipeline;

import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.features2d.FeatureDetector;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;

/**
* GripPipeline class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class GripPipeline implements VisionPipeline {

	//Outputs
	private Mat resizeImageOutput = new Mat();
	private Mat hslThresholdOutput = new Mat();
	private Mat cvDilateOutput = new Mat();
	private Mat distanceTransformOutput = new Mat();
	private Number findMinAndMaxMinVal;
	private Number findMinAndMaxMaxVal;
	private Point findMinAndMaxMinLoc = new Point();
	private Point findMinAndMaxMaxLoc = new Point();

	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	@Override	public void process(Mat source0) {
		// Step Resize_Image0:
		Mat resizeImageInput = source0;
		double resizeImageWidth = 320.0;
		double resizeImageHeight = 240.0;
		int resizeImageInterpolation = Imgproc.INTER_CUBIC;
		resizeImage(resizeImageInput, resizeImageWidth, resizeImageHeight, resizeImageInterpolation, resizeImageOutput);

		// Step HSL_Threshold0:
		Mat hslThresholdInput = resizeImageOutput;
		double[] hslThresholdHue = {0.0, 23.80625232997815};
		double[] hslThresholdSaturation = {142.95792179815473, 255.0};
		double[] hslThresholdLuminance = {55.22598870056497, 255.0};
		hslThreshold(hslThresholdInput, hslThresholdHue, hslThresholdSaturation, hslThresholdLuminance, hslThresholdOutput);

		// Step CV_dilate0:
		Mat cvDilateSrc = hslThresholdOutput;
		Mat cvDilateKernel = new Mat();
		Point cvDilateAnchor = new Point(-1, -1);
		double cvDilateIterations = 1.0;
		int cvDilateBordertype = Core.BORDER_CONSTANT;
		Scalar cvDilateBordervalue = new Scalar(-1);
		cvDilate(cvDilateSrc, cvDilateKernel, cvDilateAnchor, cvDilateIterations, cvDilateBordertype, cvDilateBordervalue, cvDilateOutput);

		// Step Distance_Transform0:
		Mat distanceTransformInput = cvDilateOutput;
		int distanceTransformType = Imgproc.DIST_L2;
        int distanceTransformMaskSize = 5;
		distanceTransform(distanceTransformInput, distanceTransformType, distanceTransformMaskSize, distanceTransformOutput);

		// Step Find_Min_and_Max0:
		Mat findMinAndMaxImage = distanceTransformOutput;
		Mat findMinAndMaxMask = new Mat();
		Ref<Number> findMinAndMaxMinValRef = new Ref<Number>();
		Ref<Number> findMinAndMaxMaxValRef = new Ref<Number>();
		findMinAndMax(findMinAndMaxImage, findMinAndMaxMask, findMinAndMaxMinValRef, findMinAndMaxMaxValRef, findMinAndMaxMinLoc, findMinAndMaxMaxLoc);
		findMinAndMaxMinVal = findMinAndMaxMinValRef.get();
		findMinAndMaxMaxVal = findMinAndMaxMaxValRef.get();

	}

	/**
	 * This method is a generated getter for the output of a Resize_Image.
	 * @return Mat output from Resize_Image.
	 */
	public Mat resizeImageOutput() {
		return resizeImageOutput;
	}

	/**
	 * This method is a generated getter for the output of a HSL_Threshold.
	 * @return Mat output from HSL_Threshold.
	 */
	public Mat hslThresholdOutput() {
		return hslThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_dilate.
	 * @return Mat output from CV_dilate.
	 */
	public Mat cvDilateOutput() {
		return cvDilateOutput;
	}

	/**
	 * This method is a generated getter for the output of a Distance_Transform.
	 * @return Mat output from Distance_Transform.
	 */
	public Mat distanceTransformOutput() {
		return distanceTransformOutput;
	}

	/**
	 * This method is a generated getter for the output of a Find_Min_and_Max.
	 * @return Number output from Find_Min_and_Max.
	 */
	public Number findMinAndMaxMinVal() {
		return findMinAndMaxMinVal;
	}

	/**
	 * This method is a generated getter for the output of a Find_Min_and_Max.
	 * @return Number output from Find_Min_and_Max.
	 */
	public Number findMinAndMaxMaxVal() {
		return findMinAndMaxMaxVal;
	}

	/**
	 * This method is a generated getter for the output of a Find_Min_and_Max.
	 * @return Point output from Find_Min_and_Max.
	 */
	public Point findMinAndMaxMinLoc() {
		return findMinAndMaxMinLoc;
	}

	/**
	 * This method is a generated getter for the output of a Find_Min_and_Max.
	 * @return Point output from Find_Min_and_Max.
	 */
	public Point findMinAndMaxMaxLoc() {
		return findMinAndMaxMaxLoc;
	}


	/**
	 * Scales and image to an exact size.
	 * @param input The image on which to perform the Resize.
	 * @param width The width of the output in pixels.
	 * @param height The height of the output in pixels.
	 * @param interpolation The type of interpolation.
	 * @param output The image in which to store the output.
	 */
	private void resizeImage(Mat input, double width, double height,
		int interpolation, Mat output) {
		Imgproc.resize(input, output, new Size(width, height), 0.0, 0.0, interpolation);
	}

	/**
	 * Segment an image based on hue, saturation, and luminance ranges.
	 *
	 * @param input The image on which to perform the HSL threshold.
	 * @param hue The min and max hue
	 * @param sat The min and max saturation
	 * @param lum The min and max luminance
	 * @param output The image in which to store the output.
	 */
	private void hslThreshold(Mat input, double[] hue, double[] sat, double[] lum,
		Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HLS);
		Core.inRange(out, new Scalar(hue[0], lum[0], sat[0]),
			new Scalar(hue[1], lum[1], sat[1]), out);
	}

	/**
	 * Expands area of higher value in an image.
	 * @param src the Image to dilate.
	 * @param kernel the kernel for dilation.
	 * @param anchor the center of the kernel.
	 * @param iterations the number of times to perform the dilation.
	 * @param borderType pixel extrapolation method.
	 * @param borderValue value to be used for a constant border.
	 * @param dst Output Image.
	 */
	private void cvDilate(Mat src, Mat kernel, Point anchor, double iterations,
	int borderType, Scalar borderValue, Mat dst) {
		if (kernel == null) {
			kernel = new Mat();
		}
		if (anchor == null) {
			anchor = new Point(-1,-1);
		}
		if (borderValue == null){
			borderValue = new Scalar(-1);
		}
		Imgproc.dilate(src, dst, kernel, anchor, (int)iterations, borderType, borderValue);
	}

	/**
	 * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
	 * @param input The image on which to perform the Distance Transform.
	 * @param type The Transform.
	 * @param maskSize the size of the mask.
	 * @param output The image in which to store the output.
	 */
	private void distanceTransform(Mat input,int type, int maskSize,
		Mat output) {
		Imgproc.distanceTransform(input, output, type, maskSize);
		output.convertTo(output, -1);
	}

	/**
	 * Finds the minimum and maximum values of the Mat as well as the associated points.
	 * @param src the Mat to find min and max for.
	 * @param mask the Mat to use as a mask for the operation.
	 * @param minVal the minimum value found in the Mat.
	 * @param maxVal the maximum value found in the Mat.
	 * @param minLoc the location of the minimum value.
	 * @param maxLoc the location of the maximum value.
	 */
	private void findMinAndMax(Mat src, Mat mask, Ref<Number> minVal,
		Ref<Number> maxVal, Point minLoc, Point maxLoc) {
		MinMaxLocResult data = Core.minMaxLoc(src);
		minVal.set(Double.valueOf(data.minVal));
		maxVal.set(Double.valueOf(data.maxVal));
		minLoc.x = data.minLoc.x;
		minLoc.y = data.minLoc.y;
		maxLoc.x = data.maxLoc.x;
		maxLoc.y = data.maxLoc.y;
	}


	/**
	 * Enables C-style output parameters in Java to avoid creating custom data classes for each
	 * operation.
	 *
	 * <p>Syntax is {@code Ref<T> varName = new Ref<T>(initValue)}.
	 * Where varName is the name of the variable and initValue is of type T and contains initial value.
	 * </p>
	 * @param <T> The type of object being referenced
	 */
	private static class Ref<T> {
		private T value;

		/**
		 * Constructor for a Ref object.
		 * @param initValue Type T initial value for the object.
		 */
		public Ref(T initValue) {
			value = initValue;
		}

		/**
		 * Constructor for a Ref object without an initial value.
		 * Equivalent to calling Ref(null)
		 */
		public Ref() {
			this(null);
		}

		/**
		 * Sets the object to contain a new value.
		 *
		 * @param newValue the new value being referenced
		 */
		public void set(T newValue) {
			value = newValue;
		}

		/**
		 * Gets the current referenced value
		 *
		 * @return the current referenced value
		 */
		public T get() {
			return value;
		}
	}

}

